<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-10T14:54:56.684Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>induction-1</title>
    <link href="http://example.com/2021/12/10/induction-1/"/>
    <id>http://example.com/2021/12/10/induction-1/</id>
    <published>2021-12-10T14:07:38.000Z</published>
    <updated>2021-12-10T14:54:56.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>在写normal3和4的时候感受到自己看题太不仔细了，normal3在最后调试答案的时候加了头和尾，一直显示flag错误，想了一想才知道这个是因为没有看清最后题目的输出。还是要把每道题都理解透彻自己反复思考去看怎么做，哪里自己没有注意到，好好去归纳总结一下。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在normal3的时候遇到了递归算法，其实一开始想的是一个replace，感觉像是给flag的值用一个str的下标来替换，调试的时候一直在很混乱的循环，也没有想到递归这层，还是平常的基础知识运用的不够熟悉，遇到这些常见的算法都反应不过来。其实按照题目的意思是一个递归的排序。</p><p>递归算法简单来说就是一种调用自身函数的算法，递归必须有明确的结束条件，不然就是无止境的循环消耗电脑内存，可以说是利弊共存。</p><p>就题目里来说递归就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = 0</span><br><span class="line">arr = []</span><br><span class="line">arr1 = []</span><br><span class="line"></span><br><span class="line">def fun(a):</span><br><span class="line">    global data</span><br><span class="line">    global arr</span><br><span class="line">    global arr1</span><br><span class="line">    if(a &lt; 64):</span><br><span class="line">        arr.append(data)</span><br><span class="line">        arr1.append(a)</span><br><span class="line">        data = data + 1</span><br><span class="line">        fun(2*a + 1)</span><br><span class="line">        fun(2*(a + 1))</span><br></pre></td></tr></table></figure><p>调用自身来进行运算</p><h2 id="hex与bytes"><a href="#hex与bytes" class="headerlink" title="hex与bytes"></a>hex与bytes</h2><p>又到了这个话题，上次写过一个hexstring和bytes的转化，写了很久，在normal4里面又碰到了这个问题。</p><img src="/2021/12/10/induction-1/1.png" class="" width="1"><img src="/2021/12/10/induction-1/2.png" class="" width="2"><p>在汇编窗口里你会发现这样的东西。<strong>byte ptr</strong>。这道题我没有调试，我直接照着伪代码逆了，结果错了，也没有想明白到底是为什么list会越界，也没有仔细去看汇编。从头再分析过来发现伪代码里的变量是被拆分了的，因为这里是把hex的字符串转成byte，然后以每两位写入。</p><img src="/2021/12/10/induction-1/3.png" class="" width="3"><p>有时候会遇到变量很多很难看，这时候就要反应过来看汇编和调试汇编了（我就没这么做就寄了），因为多个变量很有可能是组成一个地址的值或者字符，从而来replace这样，直接逆搞了好久也没有逆出东西来，一直在提示我越界。这道题其实就是一个replace，str2的下标是flag[i]的值的ascii码，只要索引str[i] ^ 0x19在str2里下标就可以了。</p><p>网上搜了一下是2018年湖湘杯的一道题，我看了爆破的脚本严重怀疑越界的可能性但应该别人出的脚本没有问题，等到有空考证了就补充上去。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>多归纳，，，不然会忘掉，，，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;在写normal3和4的时候感受到自己看题太不仔细了，normal3在最后调试答案的时候加了头和尾，一直显示</summary>
      
    
    
    
    
    <category term="归纳" scheme="http://example.com/tags/%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>《逆向工程核心原理》-1</title>
    <link href="http://example.com/2021/12/10/%E3%80%8A%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B-1/"/>
    <id>http://example.com/2021/12/10/%E3%80%8A%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B-1/</id>
    <published>2021-12-09T17:24:15.000Z</published>
    <updated>2021-12-09T18:36:28.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>《逆向工程核心原理》这本书是在todo list里最开头的，除了动手实践补充书上的知识也很重要，加班加点稍微写点笔记，让自己能看到些自己做了学了的东西吧。</p><h2 id="重要的"><a href="#重要的" class="headerlink" title="重要的"></a>重要的</h2><p>在开头书里写的是关于逆向工程。很重要的章节，告诉我要学什么，“嗯，先学这些概念吧，其他慢慢学”，不贪心，不急躁，希望自己也能体会到其中的乐趣，对生活和学习都热情以待吧。</p><p>前几章节主要讲了基本的调试程序和寄存器，但这些都是非常重要的部分，而我却一直记不住，写一些笔记来加深一下自己的印象。</p><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>首先讲了调试一个简单的hello world的程序，但在调试中需要养成良好的习惯，使调试更加方便且看起来清楚。</p><p>1.学会添加注释和标签，书中示范的是od，但不论用什么调试软件，在需要的地方添加合适的注释都是需要养成的习惯。</p><p>2.在ida调试时需要对函数名称进行重命名，以方便自己的解读。进入函数看伪代码时可以通过快捷键来简化代码，或者根据分析重定义函数类型，这些在b站ida代码修复视频中有详细介绍。</p><p>暂时没有想到其他的，如果以后发现就补充上去。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在书中介绍了四种调试hello world代码的方法，单步f8在代码量非常大的情况下是不可能使用的，一般来说我们会猜测并且设置断点，而在程序破解等实例中我们可以使用<strong>字符串检索法</strong>和<strong>API断点法</strong>来实现定位调用的函数。字符串检索在字符串被加密时也是不可行的，所以需要了解API的定义。</p><p>API是操作系统对用户应用程序提供的一系列函数，实现于xxx.dll文件。我们可以通过添加API断点来找出程序中调用函数的部分，从而找到关键代码。</p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>即大端序和小端序，BE与LE，分别采用正序和逆序的方式存储字节，大端序内存地址低位存储内存数据高位，内存地址高位位存储内存数据低位，而小端序则高存高，低存低，所以小端序是逆序输出，大端序为正序输出</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>反复查看寄存器是调试中必不可少的部分，也是很吃耐心的一部分，通过了解不同寄存器的作用可以大大缩短调试的时间，更快的了解程序的运行过程和数据的变化。也是看汇编指令的基础。</p><p>以E开头的寄存器为32位，分别为EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP。是八个通用寄存器。</p><p>以S结尾的6个段寄存器分别为CS,DC,SS,ES,FS,GS，他们都是16位的。</p><p>还有EFLAGS(程序状态与控制寄存器)和EIP指令指针寄存器。（32位）</p><p>平常看的最多的是<strong>通用寄存器</strong>，用于传送和暂存数据。有些寄存器可以分为高低位的独立寄存器，例如EAX，有32位。AX是EAX的低16位，AH又是AX的高8位，AL是AX的低8位。在调试时可以根据需要使用的字节数来观察独立寄存器的变化。</p><p>EAX:累加器（数据）                            EBP:扩展基址指针寄存器（栈内数据指针）</p><p>EBX:基址寄存器（数据指针）              ESI:源变址寄存器（字符串操作源指针）</p><p>ECX:计数器（字符串和循环操作）       EDI:目的变址寄存器（字符串操作目标指针）</p><p>EDX:数据寄存器（I/O指针）                 ESP:栈指针寄存器（栈指针）</p><p>ESP与EBP相互协调作用，EBP暂存ESP的值，ESP为栈顶指针，最后得到的值返回ESP。</p><p><strong>段寄存器</strong>在这里没有详细的阐述，只是做了简单的介绍，等到后面了解了再记录。</p><p><strong>程序状态寄存器</strong>中我们常常会看到的指令大概时ZF，即运算结果为0则它的值为1，常用作判断指令，与cmp等指令连用，OF和CF都是溢出数据时返回1，OF为有符号数据，CF为无符号数据。</p><p><strong>指令指针寄存器</strong>最后的就是EIP，即为指令地址，在寄存器窗口点击EIP即可返回到当下执行的地方。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>其实看的内容比这些要多，这些都是基础但非常重要的知识，包括后面的栈和基础的汇编指令，但实在是太困了就先搁置下来，下次一起记录。</p><p>2021.12.10/02:25   晚安。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;《逆向工程核心原理》这本书是在todo list里最开头的，除了动手实践补充书上的知识也很重要，加班加点稍微</summary>
      
    
    
    
    
    <category term="读书笔记-1" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
    
  </entry>
  
  <entry>
    <title>python字节流与字符串与aes解密函数</title>
    <link href="http://example.com/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-12-09T04:42:17.000Z</published>
    <updated>2021-12-10T08:21:21.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>最近在开始做normal系列的题目，前面了解过一些以后大体还是能够理解题目的意思，但在写脚本上面出现了很多困难，（代码力很重要），不会写脚本然后看了wp，结果wp是py2写的，会报错，语法也有一些不太一样的，让本就py很寄的我雪上加霜。。</p><p>上面的都是废话，主要写一写python字节流和字符串还有aes十分简便的带类型的解密。</p><h2 id="字节流与字符串"><a href="#字节流与字符串" class="headerlink" title="字节流与字符串"></a>字节流与字符串</h2><p>在写脚本的时候遇到了hexstring与bytes的转换问题，于是根据指点去查了一下字节流与字符串的使用和区别。以下是资料：</p><p>Python 3最重要的新特性之一是对字符串和二进制数据流做了明确的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然），也不能将字符串传入参数为字节流的函数（反之亦然）。</p><p>意思就是，不能够在字符串中拼接和存放bytes类型的数据，而字节流可以看作c语言中的数组，是不能与str混用的。</p><h2 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a>encode与decode</h2><p>那如果需要将str与bytes转换，那么就需要用到encode()（编码）和decode()（解码）两种方法，实际就是编码与解码。这也是python少数比c语言麻烦的地方。在解码编码同时需要指明编码解码类型。编码和解码类型不一致会导致出现乱码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#用utf-8编码集将a字符串编码为字节数组</span></span><br><span class="line">b1 = b.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#用utf-8编码集将变量b的字节数组解码成对应字符串</span></span><br></pre></td></tr></table></figure><p>如果不编码直接使用字符串来转换成bytes类型会报错。</p><img src="/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/1.jpg" class="" width="1"><p>也可以直接构造bytes类型数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = b&quot;abcd&quot;</span><br></pre></td></tr></table></figure><h2 id="二进制序列类型"><a href="#二进制序列类型" class="headerlink" title="二进制序列类型"></a>二进制序列类型</h2><p>bytes是不可变的二进制格式<strong>字节</strong>数据，而bytearray是可变的二进制数据，即可以对其进行操作来改变其中的数据。</p><p>在题目中遇到了hexstring转为bytes类型的问题，帮我改脚本的师傅用的是long_to_bytes，使用的模块是from Crypto.Util import number。当然byte_to_long也同样在模块里。（这个模块需要pip装）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes </span><br><span class="line">a = long_to_bytes(<span class="number">0x934d8706bed74cd6eea683c7be86b2eb</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 b&#x27;\x93M\x87\x06\xbe\xd7L\xd6\xee\xa6\x83\xc7\xbe\x86\xb2\xeb&#x27;</span></span><br></pre></td></tr></table></figure><p>经过查资料，使用binascii.b2a_hex()也可以实现同样的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">a = binascii.a2b_hex(<span class="string">b&#x27;934d8706bed74cd6eea683c7be86b2eb&#x27;</span>)<span class="comment">#必须是bytes类型</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 b&#x27;\x93M\x87\x06\xbe\xd7L\xd6\xee\xa6\x83\xc7\xbe\x86\xb2\xeb&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="AES解密函数（含aes类型）"><a href="#AES解密函数（含aes类型）" class="headerlink" title="AES解密函数（含aes类型）"></a>AES解密函数（含aes类型）</h2><p>在解决标准aes解密时，网上搜到的脚本大多数都是很多废话一大长串，实在是非常看不懂，（主要还是我菜），wp提供了一个非常简单且带有aes加密类型的解密（太好了！）于是我去了解了一下这个解密函数的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB) <span class="comment">#key为密钥</span></span><br><span class="line">flag = aes.decrypt(data) <span class="comment">#data是需要解密的内容</span></span><br></pre></td></tr></table></figure><p>这里的aes = AES.new(key, AES.MODE_ECB)中的ECB换成其他的类型也是成立的（<strong>CBC、ECB、CTR、OCF、CFB</strong>）</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>弱类型我**&amp;%￥%￥……￥#……，但是还要学……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;最近在开始做normal系列的题目，前面了解过一些以后大体还是能够理解题目的意思，但在写脚本上面出现了很多困</summary>
      
    
    
    
    
    <category term="0-1のpython" scheme="http://example.com/tags/0-1%E3%81%AEpython/"/>
    
  </entry>
  
  <entry>
    <title>python request</title>
    <link href="http://example.com/2021/12/07/python-request/"/>
    <id>http://example.com/2021/12/07/python-request/</id>
    <published>2021-12-07T13:28:39.000Z</published>
    <updated>2021-12-07T13:32:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>在写模拟登录的时候需要用到python request模块，并且要抓包发包，只能说一无所知，甚至不知道url是什么。写一写给自己科普点网络常识，以方便听懂dalao们聊技术。</p><h3 id="所需要准备的包中的内容"><a href="#所需要准备的包中的内容" class="headerlink" title="所需要准备的包中的内容"></a>所需要准备的包中的内容</h3><p>url:意思是我们常称为的网址，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;https://baidu.com&quot;</span></span><br></pre></td></tr></table></figure><p>user-agent:指用户代理，可以通过查看抓包的内容来看自己的user-agent，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">10</span>; Pixel <span class="number">2</span> Build/QQ3A<span class="number">.200805</span><span class="number">.001</span>; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">74.0</span><span class="number">.3729</span><span class="number">.186</span> Mobile Safari/<span class="number">537.36</span></span><br></pre></td></tr></table></figure><p>这些是请求头中的内容，可能需要用到的还有很多，用到了在学，寄（摆烂</p><p>Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent</p><p>这一大堆都可能会用到</p><p>因为这次需要实行的是模拟登录，所以发包包内需要的内容是一些登录相关的数据，在这里需要使用python字典来实现。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">login = &#123;</span><br><span class="line">     <span class="string">&quot;userName&quot;</span>:<span class="string">&quot;12345678901&quot;</span>,</span><br><span class="line">     <span class="string">&quot;app_id&quot;</span>:<span class="string">&quot;7&quot;</span>,</span><br><span class="line">     <span class="string">&quot;password&quot;</span>:<span class="string">&quot;c3l5czc5OTc=\n&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>准备工作做足了的话就可以开始写请求了）</p><h3 id="request-请求"><a href="#request-请求" class="headerlink" title="request 请求"></a>request 请求</h3><p>一般需要请求都是带参数的请求，get和post其实差距不是很大，从网上查了资料大概是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo requests.get(url,params=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>&#125;)</span><br><span class="line">       requests.post(url,data=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;)</span><br><span class="line">       requests.post(url,json=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果写出来大概是这样，有请求头和respnse:(此处的body和my_header是定义的py字典)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo response = requests.post(url,params=body,headers=my_header)</span><br><span class="line">       <span class="built_in">print</span>(response.json)</span><br></pre></td></tr></table></figure><p>因为这里比较疑惑data和params有什么区别，通过资料了解到这是两种携带参数的方法。</p><p>简单来说，params是用来发送查询字符串，而data、json是用来发送正文的。<br>这两种参数post方法都可以用，get方法只能发查询字符串，不能发送正文。</p><p>params会将参数key、value拼接在url后；<br>json 表示使用application/json方式提交请求。接收方request.body的内容为’{“a”: 1, “b”: 2}’的这种形式；<br>data 表示使用application/form-urlencode方式提交请求，接收方request.body的内容为a=1&amp;b=2的这种形式。</p><h3 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h3><p>其实请求里使用python字典要包括的东西很多（大概），第一次写也没完全了解大概需要去放些什么东西在请求头和包里，就抓到啥放啥）</p><p>请求头里可能还需要time out，accept之类的，补充一点互联网上捞到的看看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time_str = <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="number">1000</span> * time.time()))</span><br><span class="line">key_dict = &#123;</span><br><span class="line">    <span class="string">&quot;source&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sourceText&quot;</span>: <span class="string">&quot;发送 POST 请求&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sessionUuid &quot;</span>: <span class="string">&quot;translate_uuid&quot;</span> + time_str</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>摆烂人要为了自己兢兢业业捏</p><p>今天听的是RISE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Target = <span class="string">&#x27;have fun and rise&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Target)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;start&quot;&gt;&lt;a href=&quot;#start&quot; class=&quot;headerlink&quot; title=&quot;start&quot;&gt;&lt;/a&gt;start&lt;/h2&gt;&lt;p&gt;在写模拟登录的时候需要用到python request模块，并且要抓包发包，只能说一无所知，甚至不知道url是什么。</summary>
      
    
    
    
    
    <category term="first" scheme="http://example.com/tags/first/"/>
    
  </entry>
  
</feed>
