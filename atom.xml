<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-09T18:33:15.343Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《逆向工程核心原理》-1</title>
    <link href="http://example.com/2021/12/10/%E3%80%8A%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B-1/"/>
    <id>http://example.com/2021/12/10/%E3%80%8A%E9%80%86%E5%90%91%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B-1/</id>
    <published>2021-12-09T17:24:15.000Z</published>
    <updated>2021-12-09T18:33:15.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>《逆向工程核心原理》这本书是在todo list里最开头的，除了动手实践补充书上的知识也很重要，加班加点稍微写点笔记，让自己能看到些自己做了学了的东西吧。</p><h2 id="重要的"><a href="#重要的" class="headerlink" title="重要的"></a>重要的</h2><p>在开头书里写的是关于逆向工程。很重要的章节，告诉我要学什么，“嗯，先学这些概念吧，其他慢慢学”，不贪心，不急躁，希望自己也能体会到其中的乐趣，对生活和学习都热情以待吧。</p><p>前几章节主要讲了基本的调试程序和寄存器，但这些都是非常重要的部分，而我却一直记不住，写一些笔记来加深一下自己的印象。</p><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>首先讲了调试一个简单的hello world的程序，但在调试中需要养成良好的习惯，使调试更加方便且看起来清楚。</p><p>1.学会添加注释和标签，书中示范的是od，但不论用什么调试软件，在需要的地方添加合适的注释都是需要养成的习惯。</p><p>2.在ida调试时需要对函数名称进行重命名，以方便自己的解读。进入函数看伪代码时可以通过快捷键来简化代码，或者根据分析重定义函数类型，这些在b站ida代码修复视频中有详细介绍。</p><p>暂时没有想到其他的，如果以后发现就补充上去。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在书中介绍了四种调试hello world代码的方法，单步f8在代码量非常大的情况下是不可能使用的，一般来说我们会猜测并且设置断点，而在程序破解等实例中我们可以使用<strong>字符串检索法</strong>和<strong>API断点法</strong>来实现定位调用的函数。字符串检索在字符串被加密时也是不可行的，所以需要了解API的定义。</p><p>API是操作系统对用户应用程序提供的一系列函数，实现于xxx.dll文件。我们可以通过添加API断点来找出程序中调用函数的部分，从而找到关键代码。</p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>即大端序和小端序，BE与LE，分别采用正序和逆序的方式存储字节，大端序内存地址低位存储内存数据高位，内存地址高位位存储内存数据低位，而小端序则高存高，低存低，所以小端序是逆序输出，大端序为正序输出</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>反复查看寄存器是调试中必不可少的部分，也是很吃耐心的一部分，通过了解不同寄存器的作用可以大大缩短调试的时间，更快的了解程序的运行过程和数据的变化。也是看汇编指令的基础。</p><p>以E开头的寄存器为32位，分别为EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP。是八个通用寄存器。</p><p>以S结尾的6个段寄存器分别为CS,DC,SS,ES,FS,GS，他们都是16位的。</p><p>还有EFLAGS(程序状态与控制寄存器)和EIP指令指针寄存器。（32位）</p><p>平常看的最多的是<strong>通用寄存器</strong>，用于传送和暂存数据。有些寄存器可以分为高低位的独立寄存器，例如EAX，有32位。AX是EAX的低16位，AH又是AX的高8位，AL是AX的低8位。在调试时可以根据需要使用的字节数来观察独立寄存器的变化。</p><p>EAX:累加器（数据）                            EBP:扩展基址指针寄存器（栈内数据指针）</p><p>EBX:基址寄存器（数据指针）              ECX:源变址寄存器（字符串操作源指针）</p><p>ECX:计数器（字符串和循环操作）       EDI:目的变址寄存器（字符串操作目标指针）</p><p>EDX:数据寄存器（I/O指针）                 ESP:栈指针寄存器（栈指针）</p><p>ESP与EBP相互协调作用，EBP暂存ESP的值，ESP为栈顶指针，最后得到的值返回ESP。</p><p><strong>段寄存器</strong>在这里没有详细的阐述，只是做了简单的介绍，等到后面了解了再记录。</p><p><strong>程序状态寄存器</strong>中我们常常会看到的指令大概时ZF，即运算结果为0则它的值为1，常用作判断指令，与cmp等指令连用，OF和CF都是溢出数据时返回1，OF为有符号数据，CF为无符号数据。</p><p><strong>指令指针寄存器</strong>最后的就是EIP，即为指令地址，在寄存器窗口点击EIP即可返回到当下执行的地方。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>其实看的内容比这些要多，这些都是基础但非常重要的知识，包括后面的栈和基础的汇编指令，但实在是太困了就先搁置下来，下次一起记录。</p><p>2021.12.10/02:25   晚安。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;《逆向工程核心原理》这本书是在todo list里最开头的，除了动手实践补充书上的知识也很重要，加班加点稍微</summary>
      
    
    
    
    
    <category term="读书笔记-1" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
    
  </entry>
  
  <entry>
    <title>python字节流与字符串与aes解密函数</title>
    <link href="http://example.com/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-12-09T04:42:17.000Z</published>
    <updated>2021-12-09T06:47:16.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h2><p>最近在开始做normal系列的题目，前面了解过一些以后大体还是能够理解题目的意思，但在写脚本上面出现了很多困难，（代码力很重要），不会写脚本然后看了wp，结果wp是py2写的，会报错，语法也有一些不太一样的，让本就py很寄的我雪上加霜。。</p><p>上面的都是废话，主要写一写python字节流和字符串还有aes十分简便的带类型的解密。</p><h2 id="字节流与字符串"><a href="#字节流与字符串" class="headerlink" title="字节流与字符串"></a>字节流与字符串</h2><p>在写脚本的时候遇到了hexstring与bytes的转换问题，于是根据指点去查了一下字节流与字符串的使用和区别。以下是资料：</p><p>Python 3最重要的新特性之一是对字符串和二进制数据流做了明确的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然），也不能将字符串传入参数为字节流的函数（反之亦然）。</p><p>意思就是，不能够在字符串中拼接和存放bytes类型的数据，而字节流可以看作c语言中的数组，是不能与str混用的。</p><h2 id="encode与decode"><a href="#encode与decode" class="headerlink" title="encode与decode"></a>encode与decode</h2><p>那如果需要将str与bytes转换，那么就需要用到encode()（编码）和decode()（解码）两种方法，实际就是编码与解码。这也是python少数比c语言麻烦的地方。在解码编码同时需要指明编码解码类型。编码和解码类型不一致会导致出现乱码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = a.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#用utf-8编码集将a字符串编码为字节数组</span></span><br><span class="line">b1 = b.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#用utf-8编码集将变量b的字节数组解码成对应字符串</span></span><br></pre></td></tr></table></figure><p>如果不编码直接使用字符串来转换成bytes类型会报错。</p><img src="/2021/12/09/python%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/1.jpg" class="" width="1"><p>也可以直接构造bytes类型数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B = b&quot;abcd&quot;</span><br></pre></td></tr></table></figure><h2 id="二进制序列类型"><a href="#二进制序列类型" class="headerlink" title="二进制序列类型"></a>二进制序列类型</h2><p>bytes是不可变的二进制格式<strong>字节</strong>数据，而bytearray是可变的二进制数据，即可以对其进行操作来改变其中的数据。</p><p>在题目中遇到了hexstring转为bytes类型的问题，帮我改脚本的师傅用的是long_to_bytes，使用的模块是from Crypto.Util import number。当然byte_to_long也同样在模块里。（这个模块需要pip装）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line">a = long_to_bytes(<span class="number">0x934d8706bed74cd6eea683c7be86b2eb</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 b&#x27;\x93M\x87\x06\xbe\xd7L\xd6\xee\xa6\x83\xc7\xbe\x86\xb2\xeb&#x27;</span></span><br></pre></td></tr></table></figure><p>经过查资料，使用binascii.b2a_hex()也可以实现同样的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">a = binascii.a2b_hex(<span class="string">b&#x27;934d8706bed74cd6eea683c7be86b2eb&#x27;</span>)<span class="comment">#必须是bytes类型</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 b&#x27;\x93M\x87\x06\xbe\xd7L\xd6\xee\xa6\x83\xc7\xbe\x86\xb2\xeb&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="AES解密函数（含aes类型）"><a href="#AES解密函数（含aes类型）" class="headerlink" title="AES解密函数（含aes类型）"></a>AES解密函数（含aes类型）</h2><p>在解决标准aes解密时，网上搜到的脚本大多数都是很多废话一大长串，实在是非常看不懂，（主要还是我菜），wp提供了一个非常简单且带有aes加密类型的解密（太好了！）于是我去了解了一下这个解密函数的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB) <span class="comment">#key为密钥</span></span><br><span class="line">flag = aes.decrypt(data) <span class="comment">#data是需要解密的内容</span></span><br></pre></td></tr></table></figure><p>这里的aes = AES.new(key, AES.MODE_ECB)中的ECB换成其他的类型也是成立的（<strong>CBC、ECB、CTR、OCF、CFB</strong>）</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>弱类型我**&amp;%￥%￥……￥#……，但是还要学……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;starts&quot;&gt;&lt;a href=&quot;#starts&quot; class=&quot;headerlink&quot; title=&quot;starts&quot;&gt;&lt;/a&gt;starts&lt;/h2&gt;&lt;p&gt;最近在开始做normal系列的题目，前面了解过一些以后大体还是能够理解题目的意思，但在写脚本上面出现了很多困</summary>
      
    
    
    
    
    <category term="0-1のpython" scheme="http://example.com/tags/0-1%E3%81%AEpython/"/>
    
  </entry>
  
  <entry>
    <title>python request</title>
    <link href="http://example.com/2021/12/07/python-request/"/>
    <id>http://example.com/2021/12/07/python-request/</id>
    <published>2021-12-07T13:28:39.000Z</published>
    <updated>2021-12-07T13:32:31.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>在写模拟登录的时候需要用到python request模块，并且要抓包发包，只能说一无所知，甚至不知道url是什么。写一写给自己科普点网络常识，以方便听懂dalao们聊技术。</p><h3 id="所需要准备的包中的内容"><a href="#所需要准备的包中的内容" class="headerlink" title="所需要准备的包中的内容"></a>所需要准备的包中的内容</h3><p>url:意思是我们常称为的网址，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;https://baidu.com&quot;</span></span><br></pre></td></tr></table></figure><p>user-agent:指用户代理，可以通过查看抓包的内容来看自己的user-agent，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">10</span>; Pixel <span class="number">2</span> Build/QQ3A<span class="number">.200805</span><span class="number">.001</span>; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">74.0</span><span class="number">.3729</span><span class="number">.186</span> Mobile Safari/<span class="number">537.36</span></span><br></pre></td></tr></table></figure><p>这些是请求头中的内容，可能需要用到的还有很多，用到了在学，寄（摆烂</p><p>Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent</p><p>这一大堆都可能会用到</p><p>因为这次需要实行的是模拟登录，所以发包包内需要的内容是一些登录相关的数据，在这里需要使用python字典来实现。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">login = &#123;</span><br><span class="line">     <span class="string">&quot;userName&quot;</span>:<span class="string">&quot;12345678901&quot;</span>,</span><br><span class="line">     <span class="string">&quot;app_id&quot;</span>:<span class="string">&quot;7&quot;</span>,</span><br><span class="line">     <span class="string">&quot;password&quot;</span>:<span class="string">&quot;c3l5czc5OTc=\n&quot;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>准备工作做足了的话就可以开始写请求了）</p><h3 id="request-请求"><a href="#request-请求" class="headerlink" title="request 请求"></a>request 请求</h3><p>一般需要请求都是带参数的请求，get和post其实差距不是很大，从网上查了资料大概是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo requests.get(url,params=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>&#125;)</span><br><span class="line">       requests.post(url,data=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;)</span><br><span class="line">       requests.post(url,json=&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果写出来大概是这样，有请求头和respnse:(此处的body和my_header是定义的py字典)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo response = requests.post(url,params=body,headers=my_header)</span><br><span class="line">       <span class="built_in">print</span>(response.json)</span><br></pre></td></tr></table></figure><p>因为这里比较疑惑data和params有什么区别，通过资料了解到这是两种携带参数的方法。</p><p>简单来说，params是用来发送查询字符串，而data、json是用来发送正文的。<br>这两种参数post方法都可以用，get方法只能发查询字符串，不能发送正文。</p><p>params会将参数key、value拼接在url后；<br>json 表示使用application/json方式提交请求。接收方request.body的内容为’{“a”: 1, “b”: 2}’的这种形式；<br>data 表示使用application/form-urlencode方式提交请求，接收方request.body的内容为a=1&amp;b=2的这种形式。</p><h3 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h3><p>其实请求里使用python字典要包括的东西很多（大概），第一次写也没完全了解大概需要去放些什么东西在请求头和包里，就抓到啥放啥）</p><p>请求头里可能还需要time out，accept之类的，补充一点互联网上捞到的看看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time_str = <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="number">1000</span> * time.time()))</span><br><span class="line">key_dict = &#123;</span><br><span class="line">    <span class="string">&quot;source&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sourceText&quot;</span>: <span class="string">&quot;发送 POST 请求&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sessionUuid &quot;</span>: <span class="string">&quot;translate_uuid&quot;</span> + time_str</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>摆烂人要为了自己兢兢业业捏</p><p>今天听的是RISE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Target = <span class="string">&#x27;have fun and rise&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Target)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;start&quot;&gt;&lt;a href=&quot;#start&quot; class=&quot;headerlink&quot; title=&quot;start&quot;&gt;&lt;/a&gt;start&lt;/h2&gt;&lt;p&gt;在写模拟登录的时候需要用到python request模块，并且要抓包发包，只能说一无所知，甚至不知道url是什么。</summary>
      
    
    
    
    
    <category term="first" scheme="http://example.com/tags/first/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/12/07/hello-world/"/>
    <id>http://example.com/2021/12/07/hello-world/</id>
    <published>2021-12-07T13:11:04.121Z</published>
    <updated>2021-12-07T13:11:04.121Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
